diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100755
index 0000000..ec8d310
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,57 @@
+# Custom embedded build for Shardy, targgeting minimal build as a part of
+# tt-mlir MLIR project. This CMakeLists.txt file is mainly from StableHLO.
+
+cmake_minimum_required(VERSION 3.15.0)
+
+# CMP0116: Ninja generators transform `DEPFILE`s from `add_custom_command()`
+# New in CMake 3.20. https://cmake.org/cmake/help/latest/policy/CMP0116.html
+if(POLICY CMP0116)
+  cmake_policy(SET CMP0116 OLD)
+endif()
+
+option(SHARDY_EMBEDDED_BUILD "Build Shardy as part of another project" ON)
+option(SHARDY_ENABLE_LLD "Use LLD as the linker if available" OFF)
+
+message(STATUS "Building Shardy embedded in another project")
+project(shardy LANGUAGES CXX C)
+set(CMAKE_C_STANDARD 11)
+set(CMAKE_CXX_STANDARD 17)
+
+find_package(MLIR REQUIRED CONFIG)
+
+set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_BINARY_DIR}/bin)
+set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_BINARY_DIR}/lib)
+list(APPEND CMAKE_MODULE_PATH "${MLIR_CMAKE_DIR}")
+list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
+include(HandleLLVMOptions)
+
+include(TableGen)
+include(AddLLVM)
+include(AddMLIR)
+include(AddMLIRPython)
+
+include(CheckCXXCompilerFlag)
+include(CheckLinkerFlag)
+
+if (SHARDY_ENABLE_LLD)
+  message(STATUS "Enabling LLD as the linker")
+  add_link_options("-fuse-ld=lld")
+endif()
+
+include_directories(${LLVM_INCLUDE_DIRS})
+include_directories(${MLIR_INCLUDE_DIRS})
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+link_directories(${LLVM_BUILD_LIBRARY_DIR})
+add_definitions(${LLVM_DEFINITIONS})
+
+set(SHARDY_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+set(SHARDY_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
+
+add_compile_options(-Wno-deprecated-declarations -Wno-unused-but-set-variable -Wno-sign-compare -Wno-defaulted-function-deleted)
+
+add_subdirectory(shardy/common)
+add_subdirectory(shardy/dialect/sdy/ir)
+add_subdirectory(shardy/dialect/sdy/transforms)
+add_subdirectory(shardy/integrations/python/ir)
+add_subdirectory(shardy/integrations/c)
\ No newline at end of file
diff --git a/shardy/common/CMakeLists.txt b/shardy/common/CMakeLists.txt
new file mode 100644
index 0000000..5ae192d
--- /dev/null
+++ b/shardy/common/CMakeLists.txt
@@ -0,0 +1,18 @@
+# Shardy MLIR Common
+
+add_mlir_library(SdyCommonFileUtils
+  file_utils.cc
+  logging.cc
+  save_module_op.cc
+
+  DEPENDS
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRPass
+  MLIRSupport
+  SdyDialect
+)
diff --git a/shardy/dialect/sdy/ir/CMakeLists.txt b/shardy/dialect/sdy/ir/CMakeLists.txt
new file mode 100755
index 0000000..b2c87de
--- /dev/null
+++ b/shardy/dialect/sdy/ir/CMakeLists.txt
@@ -0,0 +1,106 @@
+# Shardy MLIR dialect.
+
+set(LLVM_TARGET_DEFINITIONS dialect.td)
+mlir_tablegen(dialect.h.inc -gen-dialect-decls -dialect=sdy)
+mlir_tablegen(dialect.cc.inc -gen-dialect-defs -dialect=sdy)
+add_public_tablegen_target(SdyDialectIncGen)
+add_dependencies(mlir-headers SdyDialectIncGen)
+add_mlir_doc(dialect SdyDialect src/autogen/md/Dialect/ -gen-dialect-doc)
+
+set(LLVM_TARGET_DEFINITIONS ops.td)
+mlir_tablegen(ops.h.inc -gen-op-decls)
+mlir_tablegen(ops.cc.inc -gen-op-defs)
+add_public_tablegen_target(SdyOpsIncGen)
+add_dependencies(mlir-headers SdyOpsIncGen)
+
+set(LLVM_TARGET_DEFINITIONS attrs.td)
+mlir_tablegen(attrs.h.inc -gen-attrdef-decls)
+mlir_tablegen(attrs.cc.inc -gen-attrdef-defs)
+add_public_tablegen_target(SdyAttrsIncGen)
+add_dependencies(mlir-headers SdyAttrsIncGen)
+
+set(LLVM_TARGET_DEFINITIONS enums.td)
+mlir_tablegen(enums.h.inc -gen-enum-decls)
+mlir_tablegen(enums.cc.inc -gen-enum-defs)
+add_public_tablegen_target(SdyEnumsIncGen)
+add_dependencies(mlir-headers SdyEnumsIncGen)
+
+set(LLVM_TARGET_DEFINITIONS op_interface.td)
+mlir_tablegen(op_interface.h.inc -gen-op-interface-decls)
+mlir_tablegen(op_interface.cc.inc -gen-op-interface-defs)
+add_public_tablegen_target(SdyOpInterfaceIncGen)
+add_dependencies(mlir-headers SdyOpInterfaceIncGen)
+
+set(LLVM_TARGET_DEFINITIONS canonicalization.td)
+mlir_tablegen(canonicalization.cc.inc -gen-rewriters)
+add_public_tablegen_target(SdyCanonicalizationIncGen)
+add_dependencies(mlir-headers SdyCanonicalizationIncGen)
+
+set(LLVM_TARGET_DEFINITIONS bytecode.td)
+mlir_tablegen(bytecode.cc.inc -gen-bytecode -bytecode-dialect=sdy)
+add_public_tablegen_target(SdyBytecodeIncGen)
+add_dependencies(mlir-headers SdyBytecodeIncGen)
+
+add_mlir_dialect_library(SdyDialect
+  bytecode.cc
+  canonicalization.cc
+  dialect.cc
+  extensions/stablehlo_extensions.cc
+  parsers.cc
+  printers.cc
+  utils.cc
+  verifiers.cc
+
+  DEPENDS
+  SdyDialectIncGen
+  SdyOpsIncGen
+  SdyAttrsIncGen
+  SdyEnumsIncGen
+  SdyOpInterfaceIncGen
+  SdyCanonicalizationIncGen
+  SdyBytecodeIncGen
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRBytecodeOpInterface
+  MLIRFuncDialect
+  MLIRIR
+  MLIRInferTypeOpInterface
+  MLIRTransformUtils
+  MLIRShapeDialect
+  MLIRSideEffectInterfaces
+  MLIRSupport
+  StablehloAssemblyFormat
+  StablehloOps
+  StablehloTypeInference
+)
+
+target_include_directories(SdyDialect INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
+
+add_mlir_dialect_library(SdyRegister
+  register.cc
+
+  LINK_LIBS PUBLIC
+  SdyDialect
+  MLIRFuncDialect
+  MLIRFuncAllExtensions
+  MLIRIR
+  StablehloOps
+)
+
+target_include_directories(SdyRegister INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
+
+add_mlir_dialect_library(SdyAxisListRef
+  axis_list_ref.cc
+
+  LINK_LIBS PUBLIC
+  SdyDialect
+  LLVMSupport
+  MLIRSupport
+)
diff --git a/shardy/dialect/sdy/transforms/CMakeLists.txt b/shardy/dialect/sdy/transforms/CMakeLists.txt
new file mode 100755
index 0000000..90e2fc5
--- /dev/null
+++ b/shardy/dialect/sdy/transforms/CMakeLists.txt
@@ -0,0 +1,26 @@
+# Shardy MLIR Transforms Passes
+
+add_subdirectory(common)
+add_subdirectory(export)
+add_subdirectory(import)
+add_subdirectory(propagation)
+
+add_mlir_library(SdyTransformsPasses
+  passes.cc
+
+  DEPENDS
+  SdyTransformsExportPasses
+  SdyTransformsImportPasses
+  SdyTransformsPropagationPasses
+
+  LINK_LIBS PUBLIC
+  MLIRPass
+  SdyTransformsExportPasses
+  SdyTransformsImportPasses
+  SdyTransformsPropagationPasses
+)
+
+target_include_directories(SdyTransformsPasses INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
diff --git a/shardy/dialect/sdy/transforms/common/CMakeLists.txt b/shardy/dialect/sdy/transforms/common/CMakeLists.txt
new file mode 100755
index 0000000..3b414d1
--- /dev/null
+++ b/shardy/dialect/sdy/transforms/common/CMakeLists.txt
@@ -0,0 +1,29 @@
+# Shardy MLIR Transforms Common
+
+add_mlir_library(SdyTransformsCommonOpProperties
+  op_properties.cc
+
+  DEPENDS
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  MLIRIR
+  MLIRSupport
+  StablehloBase
+  StablehloOps
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsCommonShardingWalker
+  sharding_walker.cc
+
+  DEPENDS
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRSupport
+  SdyDialect
+)
diff --git a/shardy/dialect/sdy/transforms/export/CMakeLists.txt b/shardy/dialect/sdy/transforms/export/CMakeLists.txt
new file mode 100755
index 0000000..f23330d
--- /dev/null
+++ b/shardy/dialect/sdy/transforms/export/CMakeLists.txt
@@ -0,0 +1,94 @@
+# Shardy MLIR Transform Export Passes and Pipeline
+
+set(LLVM_TARGET_DEFINITIONS passes.td)
+mlir_tablegen(passes.h.inc -gen-pass-decls -name=SdyExport)
+add_public_tablegen_target(SdyExportPassesIncGen)
+add_dependencies(mlir-headers SdyExportPassesIncGen)
+add_mlir_doc(passes SdyTransformsExportPasses ./ -gen-pass-doc)
+
+add_mlir_library(SdyExplicitReshardsUtil
+  explicit_reshards_util.cc
+
+  DEPENDS
+  SdyCommonFileUtils
+  SdyAxisListRef
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+  SdyTransformsPropagationOpShardingRuleRegistry
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyTransformsPropagationDebuggingSourceSharding
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRPass
+  MLIRRewrite
+  MLIRSideEffectInterfaces
+  MLIRSupport
+  MLIRTransformUtils
+  StablehloOps
+)
+
+add_mlir_library(SdyTransformsExportPasses
+  close_shardings.cc
+  constant_or_scalar_merger.cc
+  drop_sharding_rules.cc
+  export_pipeline.cc
+  insert_explicit_reshards.cc
+  remove_ag_rs_for_cmv1.cc
+  remove_propagation_debug_info.cc
+  remove_sharding_groups.cc
+  reshard_to_collectives.cc
+  sharding_constraint_to_reshard.cc
+  sink_data_flow_edges.cc
+  update_non_divisible_input_output_shardings.cc
+
+  DEPENDS
+  SdyExplicitReshardsUtil
+  SdyExportPassesIncGen
+  SdyCommonFileUtils
+  SdyAxisListRef
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+  SdyTransformsPropagationOpShardingRuleRegistry
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyTransformsPropagationDebuggingSourceSharding
+  SdyTransformsImportPasses
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRPass
+  MLIRRewrite
+  MLIRSideEffectInterfaces
+  MLIRSupport
+  MLIRTransformUtils
+  StablehloOps
+  SdyCommonFileUtils
+  SdyAxisListRef
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+  SdyTransformsPropagationOpShardingRuleRegistry
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyTransformsPropagationDebuggingSourceSharding
+  SdyExplicitReshardsUtil
+  SdyTransformsImportPasses
+)
+
+target_include_directories(SdyTransformsExportPasses INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
+
+target_include_directories(SdyExplicitReshardsUtil INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
diff --git a/shardy/dialect/sdy/transforms/import/CMakeLists.txt b/shardy/dialect/sdy/transforms/import/CMakeLists.txt
new file mode 100755
index 0000000..c302390
--- /dev/null
+++ b/shardy/dialect/sdy/transforms/import/CMakeLists.txt
@@ -0,0 +1,47 @@
+# Shardy MLIR Transforms Import Passes and Pipeline
+
+set(LLVM_TARGET_DEFINITIONS passes.td)
+mlir_tablegen(passes.h.inc -gen-pass-decls -name=SdyImport)
+add_public_tablegen_target(SdyTransformsImportPassesIncGen)
+add_dependencies(mlir-headers SdyTransformsImportPassesIncGen)
+add_mlir_doc(passes SdyTransformsImportPasses ./ -gen-pass-doc)
+
+add_mlir_library(SdyTransformsImportPasses
+  add_data_flow_edges.cc
+  apply_sharding_constraints.cc
+  constant_or_scalar_splitter.cc
+  import_pipeline.cc
+  inline_meshes.cc
+  lift_inlined_meshes.cc
+  manual_axes_cleanup.cc
+  remove_size_one_axes.cc
+  sharding_group_import.cc
+
+  DEPENDS
+  SdyTransformsImportPassesIncGen
+  SdyCommonFileUtils
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRPass
+  MLIRRewrite
+  MLIRSideEffectInterfaces
+  MLIRSupport
+  MLIRTransformUtils
+  MLIRTransforms
+  StablehloOps
+  SdyCommonFileUtils
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+)
+
+target_include_directories(SdyTransformsImportPasses INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
diff --git a/shardy/dialect/sdy/transforms/propagation/CMakeLists.txt b/shardy/dialect/sdy/transforms/propagation/CMakeLists.txt
new file mode 100755
index 0000000..809f431
--- /dev/null
+++ b/shardy/dialect/sdy/transforms/propagation/CMakeLists.txt
@@ -0,0 +1,188 @@
+# Shardy MLIR Transform Propagation System
+
+add_subdirectory(debugging)
+
+set(LLVM_TARGET_DEFINITIONS passes.td)
+mlir_tablegen(passes.h.inc -gen-pass-decls -name=SdyPropagation)
+add_public_tablegen_target(SdyTransformsPropagationPassesIncGen)
+add_dependencies(mlir-headers SdyTransformsPropagationPassesIncGen)
+add_mlir_doc(passes SdyTransformsPropagationPasses ./ -gen-pass-doc)
+
+add_mlir_library(SdyTransformsPropagationPasses
+  aggressive_propagation.cc
+  basic_propagation.cc
+  op_priority_propagation.cc
+  populate_op_sharding_rules.cc
+  propagation_pipeline.cc
+  user_priority_propagation.cc
+
+  DEPENDS
+  SdyTransformsPropagationAggressiveFactorPropagation
+  SdyTransformsPropagationAutoPartitionerRegistry
+  SdyTransformsPropagationBasicFactorPropagation
+  SdyTransformsPropagationOpShardingRuleBuilder
+  SdyTransformsPropagationOpShardingRuleRegistry
+  SdyTransformsPropagationPassesIncGen
+  SdyTransformsPropagationShardingGroupMap
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyCommonFileUtils
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+  SdyTransformsExportPasses
+  SdyTransformsImportPasses
+  SdyTransformsPropagationDebuggingSourceSharding
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRBufferizationDialect
+  MLIRFuncDialect
+  MLIRIR
+  MLIRPass
+  MLIRRewrite
+  MLIRSideEffectInterfaces
+  MLIRSupport
+  MLIRTransformUtils
+  StablehloOps
+  SdyTransformsPropagationAggressiveFactorPropagation
+  SdyTransformsPropagationAutoPartitionerRegistry
+  SdyTransformsPropagationBasicFactorPropagation
+  SdyTransformsPropagationOpShardingRuleBuilder
+  SdyTransformsPropagationOpShardingRuleRegistry
+  SdyTransformsPropagationShardingGroupMap
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyCommonFileUtils
+  SdyDialect
+  SdyTransformsCommonOpProperties
+  SdyTransformsCommonShardingWalker
+  SdyTransformsExportPasses
+  SdyTransformsImportPasses
+  SdyTransformsPropagationDebuggingSourceSharding
+)
+
+target_include_directories(SdyTransformsPropagationPasses INTERFACE
+  $<BUILD_INTERFACE:${SHARDY_SOURCE_DIR}>
+  $<BUILD_INTERFACE:${SHARDY_BINARY_DIR}>
+)
+
+add_mlir_library(SdyTransformsPropagationOpShardingRuleBuilder
+  op_sharding_rule_builder.cc
+
+  DEPENDS
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRIR
+  MLIRSupport
+  StablehloOps
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsPropagationOpShardingRuleRegistry
+  op_sharding_rule_registry.cc
+
+  DEPENDS
+  SdyTransformsPropagationOpShardingRuleBuilder
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRSupport
+  StablehloOps
+  SdyTransformsPropagationOpShardingRuleBuilder
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsPropagationShardingGroupMap
+  sharding_group_map.cc
+
+  DEPENDS
+  SdyTransformsPropagationUtils
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRIR
+  MLIRSupport
+  SdyTransformsPropagationUtils
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsPropagationShardingProjection
+  sharding_projection.cc
+
+  DEPENDS
+  SdyTransformsPropagationUtils
+  SdyAxisListRef
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRIR
+  MLIRSupport
+  SdyTransformsPropagationUtils
+  SdyAxisListRef
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsPropagationAutoPartitionerRegistry
+  auto_partitioner_registry.cc
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRIR
+  MLIRPass
+)
+
+add_mlir_library(SdyTransformsPropagationUtils
+  utils.cc
+
+  DEPENDS
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRSupport
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsPropagationBasicFactorPropagation
+  basic_factor_propagation.cc
+
+  DEPENDS
+  SdyTransformsPropagationShardingProjection
+  SdyDialect
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRIR
+  MLIRSupport
+  SdyTransformsPropagationShardingProjection
+  SdyDialect
+)
+
+add_mlir_library(SdyTransformsPropagationAggressiveFactorPropagation
+  aggressive_factor_propagation.cc
+
+  DEPENDS
+  SdyTransformsPropagationBasicFactorPropagation
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyDialect
+  SdyTransformsCommonOpProperties
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRIR
+  MLIRSupport
+  SdyTransformsPropagationBasicFactorPropagation
+  SdyTransformsPropagationShardingProjection
+  SdyTransformsPropagationUtils
+  SdyDialect
+  SdyTransformsCommonOpProperties
+)
diff --git a/shardy/dialect/sdy/transforms/propagation/debugging/CMakeLists.txt b/shardy/dialect/sdy/transforms/propagation/debugging/CMakeLists.txt
new file mode 100644
index 0000000..dc33501
--- /dev/null
+++ b/shardy/dialect/sdy/transforms/propagation/debugging/CMakeLists.txt
@@ -0,0 +1,17 @@
+# Shardy MLIR Transforms Propagation Debugging System
+
+add_mlir_library(SdyTransformsPropagationDebuggingSourceSharding
+  source_sharding.cc
+
+  DEPENDS
+  SdyDialect
+  SdyTransformsPropagationShardingProjection
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRFuncDialect
+  MLIRIR
+  MLIRSupport
+  SdyDialect
+  SdyTransformsPropagationShardingProjection
+)
diff --git a/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc b/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc
index a73917b..78cc827 100644
--- a/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc
+++ b/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc
@@ -346,6 +346,7 @@ void saveShardingOriginsOnModule(
 // the case for the target of the edge, because if the source appears multiple
 // times, then it's because it effects multiple other operands/results in the
 // op.
+[[maybe_unused]]
 bool insertSeenValue(Operation* op, const PropagationEdge& edge,
                      llvm::SmallDenseSet<Value>& seenValues) {
   EdgeNode target = edge.target;
diff --git a/shardy/dialect/sdy/transforms/propagation/op_sharding_rule_registry.cc b/shardy/dialect/sdy/transforms/propagation/op_sharding_rule_registry.cc
index ab93067..283d6ad 100644
--- a/shardy/dialect/sdy/transforms/propagation/op_sharding_rule_registry.cc
+++ b/shardy/dialect/sdy/transforms/propagation/op_sharding_rule_registry.cc
@@ -303,6 +303,37 @@ OpShardingRuleAttr createOpShardingRule(Operation* op,
         }
         return builder.build();
       })
+      .Case<stablehlo::BatchNormInferenceOp>(
+        [conservativePropagation](stablehlo::BatchNormInferenceOp bn) {
+          auto inTy  = llvm::cast<mlir::RankedTensorType>(bn.getOperand().getType());
+          auto outTy = llvm::cast<mlir::RankedTensorType>(bn.getResult().getType());
+
+          OpShardingRuleBuilder builder(bn);
+
+          const int64_t numOperands = static_cast<int64_t>(bn->getNumOperands());
+          llvm::SmallVector<int64_t> opDims(numOperands, kNullDim);
+
+          for (auto [dU, dimSize] : llvm::enumerate(inTy.getShape())) {
+            const int64_t d = static_cast<int64_t>(dU);
+            std::fill(opDims.begin(), opDims.end(), kNullDim);
+            opDims[0] = d;
+            builder.addFactor(opDims, d, dimSize);
+          }
+
+          const int64_t featAxis = static_cast<int64_t>(bn.getFeatureIndex());
+          const int64_t C = outTy.getDimSize(featAxis);
+
+          for (int64_t paramIdx : {1LL, 2LL, 3LL, 4LL}) {
+            std::fill(opDims.begin(), opDims.end(), kNullDim);
+            opDims[paramIdx] = 0;
+            auto factorType = conservativePropagation ? FactorType::kNeedReplication
+                                                        : FactorType::kPassThrough;
+            builder.addFactor(opDims, kNullDim, C,
+                  factorType, true);
+          }
+
+          return builder.build();
+        })
       .Case<stablehlo::BitcastConvertOp>(
           [](stablehlo::BitcastConvertOp bitcastConvert) {
             ArrayRef<int64_t> inShape =
@@ -685,6 +716,12 @@ OpShardingRuleAttr createOpShardingRule(Operation* op,
                   /*isBlocked=*/usedByRngBitGenerator)
               .build();
         }
+        // Check if the custom call implements the ShardingRuleOpInterface.
+        if (auto shardingRuleOp =
+                  llvm::dyn_cast<ShardingRuleOpInterface>(customCall.getOperation())) {
+          return shardingRuleOp.getShardingRule();
+        }
+
         // TODO(b/327191011): output unregistered op stats instead.
         static llvm::once_flag onceFlag;
         emitOpWarningOnce(
@@ -1093,6 +1130,16 @@ OpShardingRuleAttr createOpShardingRule(Operation* op,
             return builder.build();
           })
       .Case<stablehlo::ScatterOp>([](stablehlo::ScatterOp scatter) {
+        // Check if the scatter op implements the ShardingRuleOpInterface.
+        if (auto shardingRuleOp =
+              llvm::dyn_cast<ShardingRuleOpInterface>(scatter.getOperation())) {
+          // Try to get custom rule - if it returns non-null, use it.
+          if (auto customRule = shardingRuleOp.getShardingRule()) {
+            return customRule;
+          }
+          // If custom rule returns null, fall through to default.
+        }
+
         OpShardingRuleBuilder builder(scatter);

         // Since all inputs and results have compatible shapes, we can look at
diff --git a/shardy/integrations/c/CMakeLists.txt b/shardy/integrations/c/CMakeLists.txt
new file mode 100644
index 0000000..fdd50c4
--- /dev/null
+++ b/shardy/integrations/c/CMakeLists.txt
@@ -0,0 +1,20 @@
+add_mlir_public_c_api_library(SdyCAPI
+  PARTIAL_SOURCES_INTENDED
+  attributes.cc
+  dialect.cc
+  passes.cc
+
+  LINK_LIBS PUBLIC
+  LLVMSupport
+  MLIRBytecodeOpInterface
+  MLIRFuncDialect
+  MLIRIR
+  MLIRInferTypeOpInterface
+  MLIRTransformUtils
+  MLIRShapeDialect
+  MLIRSideEffectInterfaces
+  MLIRSupport
+  StablehloAssemblyFormat
+  StablehloOps
+  StablehloTypeInference
+)
diff --git a/shardy/integrations/c/attributes.cc b/shardy/integrations/c/attributes.cc
index b683d09..2ca7d7b 100644
--- a/shardy/integrations/c/attributes.cc
+++ b/shardy/integrations/c/attributes.cc
@@ -66,6 +66,10 @@ int64_t sdyMeshAxisAttrGetSize(MlirAttribute attr) {
   return unwrapAttr<sdy::MeshAxisAttr>(attr).getSize();
 }

+MlirAttribute sdyMeshAxisAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::MeshAxisAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // MeshAttr
 //===----------------------------------------------------------------------===//
@@ -98,6 +102,10 @@ MlirAttribute sdyMeshAttrGetAxesElem(MlirAttribute attr, intptr_t pos) {
   return wrap(unwrapAttr<sdy::MeshAttr>(attr).getAxes()[pos]);
 }

+MlirAttribute sdyMeshAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::MeshAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // SubAxisInfoAttr
 //===----------------------------------------------------------------------===//
@@ -119,6 +127,10 @@ int64_t sdySubAxisInfoAttrGetSize(MlirAttribute attr) {
   return unwrapAttr<sdy::SubAxisInfoAttr>(attr).getSize();
 }

+MlirAttribute sdySubAxisInfoAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::SubAxisInfoAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // AxisRefAttr
 //===----------------------------------------------------------------------===//
@@ -146,6 +158,10 @@ MlirAttribute sdyAxisRefAttrGetSubAxisInfo(MlirAttribute attr) {
   return subAsisInfo ? wrap(subAsisInfo) : MlirAttribute();
 }

+MlirAttribute sdyAxisRefAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::AxisRefAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // DimensionShardingAttr
 //===----------------------------------------------------------------------===//
@@ -182,6 +198,10 @@ int64_t sdyDimensionShardingAttrGetPriority(MlirAttribute attr) {
   return priority.has_value() ? *priority : -1;
 }

+MlirAttribute sdyDimensionShardingAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::DimensionShardingAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // TensorShardingAttr
 //===----------------------------------------------------------------------===//
@@ -238,6 +258,10 @@ MlirAttribute sdyTensorShardingAttrGetUnreducedAxesElem(MlirAttribute attr,
       unwrapAttr<sdy::TensorShardingAttr>(attr).getUnreducedAxes()[pos]);
 }

+MlirAttribute sdyTensorShardingAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::TensorShardingAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // TensorShardingPerValueAttr
 //===----------------------------------------------------------------------===//
@@ -266,6 +290,10 @@ MlirAttribute sdyTensorShardingPerValueAttrGetShardingsElem(MlirAttribute attr,
       unwrapAttr<sdy::TensorShardingPerValueAttr>(attr).getShardings()[pos]);
 }

+MlirAttribute sdyTensorShardingPerValueAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::TensorShardingPerValueAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // DimMappingAttr
 //===----------------------------------------------------------------------===//
@@ -289,6 +317,10 @@ int64_t sdyDimMappingAttrGetFactorIndicesElem(MlirAttribute attr,
   return unwrapAttr<sdy::DimMappingAttr>(attr).getFactorIndices()[pos];
 }

+MlirAttribute sdyDimMappingAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::DimMappingAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // TensorMappingAttr
 //===----------------------------------------------------------------------===//
@@ -316,6 +348,10 @@ MlirAttribute sdyTensorMappingAttrGetDimMappingsElem(MlirAttribute attr,
   return wrap(unwrapAttr<sdy::TensorMappingAttr>(attr).getDimMappings()[pos]);
 }

+MlirAttribute sdyTensorMappingAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::TensorMappingAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // OpShardingRuleAttr
 //===----------------------------------------------------------------------===//
@@ -423,6 +459,10 @@ int64_t sdyOpShardingRuleAttrGetBlockedPropagationFactorsElem(
       .getBlockedPropagationFactors()[pos];
 }

+MlirAttribute sdyOpShardingRuleAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::OpShardingRuleAttr>(unwrap(attr)));
+}
+
 //===----------------------------------------------------------------------===//
 // ManualAxesAttr
 //===----------------------------------------------------------------------===//
@@ -446,4 +486,56 @@ MlirStringRef sdyManualAxesAttrGetAxesElem(
   return wrap(unwrapAttr<sdy::ManualAxesAttr>(attr)[pos].getValue());
 }

+MlirAttribute sdyManualAxesAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::ManualAxesAttr>(unwrap(attr)));
+}
+
+//===----------------------------------------------------------------------===//
+// AxisRefListAttr
+//===----------------------------------------------------------------------===//
+
+bool sdyAttributeIsAAxisRefListAttr(MlirAttribute attr) {
+  return mlir::isa<sdy::AxisRefListAttr>(unwrap(attr));
+}
+
+MlirAttribute sdyAxisRefListAttrGet(MlirContext ctx, intptr_t nAxisRefs, const MlirAttribute* axisRefs) {
+  return wrap(sdy::AxisRefListAttr::get(unwrap(ctx), unwrapAttrs<sdy::AxisRefAttr>(axisRefs, nAxisRefs)));
+}
+
+intptr_t sdyAxisRefListAttrGetAxisRefsSize(MlirAttribute attr) {
+  return unwrapAttr<sdy::AxisRefListAttr>(attr).getValue().size();
+}
+
+MlirAttribute sdyAxisRefListAttrGetAxisRefsElem(MlirAttribute attr, intptr_t pos) {
+  return wrap(unwrapAttr<sdy::AxisRefListAttr>(attr).getValue()[pos]);
+}
+
+MlirAttribute sdyAxisRefListAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::AxisRefListAttr>(unwrap(attr)));
+}
+
+//===----------------------------------------------------------------------===//
+// ListOfAxisRefListsAttr
+//===----------------------------------------------------------------------===//
+
+bool sdyAttributeIsAListOfAxisRefListsAttr(MlirAttribute attr) {
+  return mlir::isa<sdy::ListOfAxisRefListsAttr>(unwrap(attr));
+}
+
+MlirAttribute sdyListOfAxisRefListsAttrGet(MlirContext ctx, intptr_t nAxisRefLists, const MlirAttribute* axisRefLists) {
+  return wrap(sdy::ListOfAxisRefListsAttr::get(unwrap(ctx), unwrapAttrs<sdy::AxisRefListAttr>(axisRefLists, nAxisRefLists)));
+}
+
+intptr_t sdyListOfAxisRefListsAttrGetAxisRefListsSize(MlirAttribute attr) {
+  return unwrapAttr<sdy::ListOfAxisRefListsAttr>(attr).getValue().size();
+}
+
+MlirAttribute sdyListOfAxisRefListsAttrGetAxisRefListsElem(MlirAttribute attr, intptr_t pos) {
+  return wrap(unwrapAttr<sdy::ListOfAxisRefListsAttr>(attr).getValue()[pos]);
+}
+
+MlirAttribute sdyListOfAxisRefListsAttrMaybeDowncast(MlirAttribute attr) {
+  return wrap(mlir::cast<sdy::ListOfAxisRefListsAttr>(unwrap(attr)));
+}
+
 }  // extern "C"
diff --git a/shardy/integrations/c/attributes.h b/shardy/integrations/c/attributes.h
index b6e77c9..e3a6813 100644
--- a/shardy/integrations/c/attributes.h
+++ b/shardy/integrations/c/attributes.h
@@ -40,6 +40,9 @@ MLIR_CAPI_EXPORTED MlirStringRef sdyMeshAxisAttrGetName(MlirAttribute attr);

 MLIR_CAPI_EXPORTED int64_t sdyMeshAxisAttrGetSize(MlirAttribute attr);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyMeshAxisAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // MeshAttr
 //===----------------------------------------------------------------------===//
@@ -61,6 +64,9 @@ MLIR_CAPI_EXPORTED intptr_t sdyMeshAttrGetAxesSize(MlirAttribute attr);
 MLIR_CAPI_EXPORTED MlirAttribute sdyMeshAttrGetAxesElem(MlirAttribute attr,
                                                         intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyMeshAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // SubAxisInfoAttr
 //===----------------------------------------------------------------------===//
@@ -75,6 +81,9 @@ MLIR_CAPI_EXPORTED int64_t sdySubAxisInfoAttrGetPreSize(MlirAttribute attr);

 MLIR_CAPI_EXPORTED int64_t sdySubAxisInfoAttrGetSize(MlirAttribute attr);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdySubAxisInfoAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // AxisRefAttr
 //===----------------------------------------------------------------------===//
@@ -92,6 +101,9 @@ MLIR_CAPI_EXPORTED MlirStringRef sdyAxisRefAttrGetName(MlirAttribute attr);
 MLIR_CAPI_EXPORTED MlirAttribute
 sdyAxisRefAttrGetSubAxisInfo(MlirAttribute attr);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyAxisRefAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // DimensionShardingAttr
 //===----------------------------------------------------------------------===//
@@ -116,6 +128,9 @@ MLIR_CAPI_EXPORTED bool sdyDimensionShardingAttrGetIsClosed(MlirAttribute attr);
 MLIR_CAPI_EXPORTED int64_t
 sdyDimensionShardingAttrGetPriority(MlirAttribute attr);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyDimensionShardingAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // TensorShardingAttr
 //===----------------------------------------------------------------------===//
@@ -149,6 +164,9 @@ sdyTensorShardingAttrGetUnreducedAxesSize(MlirAttribute attr);
 MLIR_CAPI_EXPORTED MlirAttribute
 sdyTensorShardingAttrGetUnreducedAxesElem(MlirAttribute attr, intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyTensorShardingAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // TensorShardingPerValueAttr
 //===----------------------------------------------------------------------===//
@@ -165,6 +183,9 @@ sdyTensorShardingPerValueAttrGetShardingsSize(MlirAttribute attr);
 MLIR_CAPI_EXPORTED MlirAttribute
 sdyTensorShardingPerValueAttrGetShardingsElem(MlirAttribute attr, intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyTensorShardingPerValueAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // DimMappingAttr
 //===----------------------------------------------------------------------===//
@@ -180,6 +201,9 @@ sdyDimMappingAttrGetFactorIndicesSize(MlirAttribute attr);
 MLIR_CAPI_EXPORTED int64_t
 sdyDimMappingAttrGetFactorIndicesElem(MlirAttribute attr, intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyDimMappingAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // TensorMappingAttr
 //===----------------------------------------------------------------------===//
@@ -197,6 +221,9 @@ sdyTensorMappingAttrGetDimMappingsSize(MlirAttribute attr);
 MLIR_CAPI_EXPORTED MlirAttribute
 sdyTensorMappingAttrGetDimMappingsElem(MlirAttribute attr, intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyTensorMappingAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // OpShardingRuleAttr
 //===----------------------------------------------------------------------===//
@@ -258,6 +285,9 @@ MLIR_CAPI_EXPORTED int64_t
 sdyOpShardingRuleAttrGetBlockedPropagationFactorsElem(MlirAttribute attr,
                                                       intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyOpShardingRuleAttrMaybeDowncast(MlirAttribute attr);
+
 //===----------------------------------------------------------------------===//
 // ManualAxesAttr
 //===----------------------------------------------------------------------===//
@@ -272,6 +302,37 @@ MLIR_CAPI_EXPORTED intptr_t sdyManualAxesAttrGetAxesSize(MlirAttribute attr);
 MLIR_CAPI_EXPORTED MlirStringRef sdyManualAxesAttrGetAxesElem(
   MlirAttribute attr, intptr_t pos);

+MLIR_CAPI_EXPORTED MlirAttribute
+sdyManualAxesAttrMaybeDowncast(MlirAttribute attr);
+
+//===----------------------------------------------------------------------===//
+// AxisRefListAttr
+//===----------------------------------------------------------------------===//
+
+MLIR_CAPI_EXPORTED bool sdyAttributeIsAAxisRefListAttr(MlirAttribute attr);
+
+MLIR_CAPI_EXPORTED MlirAttribute sdyAxisRefListAttrGet(MlirContext ctx, intptr_t nAxisRefs, const MlirAttribute* axisRefs);
+
+MLIR_CAPI_EXPORTED intptr_t sdyAxisRefListAttrGetAxisRefsSize(MlirAttribute attr);
+
+MLIR_CAPI_EXPORTED MlirAttribute sdyAxisRefListAttrGetAxisRefsElem(MlirAttribute attr, intptr_t pos);
+
+MLIR_CAPI_EXPORTED MlirAttribute sdyAxisRefListAttrMaybeDowncast(MlirAttribute attr);
+
+//===----------------------------------------------------------------------===//
+// ListOfAxisRefListsAttr
+//===----------------------------------------------------------------------===//
+
+MLIR_CAPI_EXPORTED bool sdyAttributeIsAListOfAxisRefListsAttr(MlirAttribute attr);
+
+MLIR_CAPI_EXPORTED MlirAttribute sdyListOfAxisRefListsAttrGet(MlirContext ctx, intptr_t nAxisRefLists, const MlirAttribute* axisRefLists);
+
+MLIR_CAPI_EXPORTED intptr_t sdyListOfAxisRefListsAttrGetAxisRefListsSize(MlirAttribute attr);
+
+MLIR_CAPI_EXPORTED MlirAttribute sdyListOfAxisRefListsAttrGetAxisRefListsElem(MlirAttribute attr, intptr_t pos);
+
+MLIR_CAPI_EXPORTED MlirAttribute sdyListOfAxisRefListsAttrMaybeDowncast(MlirAttribute attr);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/shardy/integrations/python/ir/CMakeLists.txt b/shardy/integrations/python/ir/CMakeLists.txt
new file mode 100644
index 0000000..cbb4d66
--- /dev/null
+++ b/shardy/integrations/python/ir/CMakeLists.txt
@@ -0,0 +1,30 @@
+# Shardy MLIR Module
+
+declare_mlir_python_sources(SdyPythonSources)
+declare_mlir_python_sources(SdyPythonSources.Dialects
+  ADD_TO_PARENT SdyPythonSources
+)
+
+declare_mlir_dialect_python_bindings(
+  ADD_TO_PARENT SdyPythonSources.Dialects
+  ROOT_DIR "${CMAKE_CURRENT_SOURCE_DIR}"
+  TD_FILE dialects/sdy_ops.td
+  GEN_ENUM_BINDINGS ON
+  GEN_ENUM_BINDINGS_TD_FILE dialects/sdy_enums.td
+  SOURCES dialects/sdy.py
+  DIALECT_NAME sdy
+)
+
+declare_mlir_python_sources(SdyPythonExtensions)
+declare_mlir_python_extension(SdyPythonExtensions.Main
+  MODULE_NAME _sdy
+  ADD_TO_PARENT SdyPythonExtensions
+  PYTHON_BINDINGS_LIBRARY nanobind
+  SOURCES
+    sdy_module.cc
+  EMBED_CAPI_LINK_LIBS
+    SdyCAPI
+  PRIVATE_LINK_LIBS
+    SdyCAPI
+    LLVMSupport
+)
diff --git a/shardy/integrations/python/ir/dialects/sdy.py b/shardy/integrations/python/ir/dialects/sdy.py
new file mode 100644
index 0000000..7cd59c6
--- /dev/null
+++ b/shardy/integrations/python/ir/dialects/sdy.py
@@ -0,0 +1,20 @@
+# Copyright 2024 The Shardy Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ==============================================================================
+"""Python bindings for the SDY dialect."""
+
+# pylint: disable=wildcard-import
+from .._mlir_libs._sdy import *
+from ._sdy_enum_gen import *
+from ._sdy_ops_gen import *
diff --git a/shardy/integrations/python/ir/dialects/sdy_enums.td b/shardy/integrations/python/ir/dialects/sdy_enums.td
new file mode 100644
index 0000000..d4354c1
--- /dev/null
+++ b/shardy/integrations/python/ir/dialects/sdy_enums.td
@@ -0,0 +1,21 @@
+/* Copyright 2025 The Shardy Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef SHARDY_INTEGRATIONS_PYTHON_SDY_ENUMS
+#define SHARDY_INTEGRATIONS_PYTHON_SDY_ENUMS
+
+include "shardy/dialect/sdy/ir/enums.td"
+
+#endif // SHARDY_INTEGRATIONS_PYTHON_SDY_ENUMS
diff --git a/shardy/integrations/python/ir/dialects/sdy_ops.td b/shardy/integrations/python/ir/dialects/sdy_ops.td
new file mode 100644
index 0000000..30a5cf9
--- /dev/null
+++ b/shardy/integrations/python/ir/dialects/sdy_ops.td
@@ -0,0 +1,21 @@
+/* Copyright 2024 The Shardy Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef SHARDY_INTEGRATIONS_PYTHON_SDY_OPS
+#define SHARDY_INTEGRATIONS_PYTHON_SDY_OPS
+
+include "shardy/dialect/sdy/ir/ops.td"
+
+#endif
diff --git a/shardy/integrations/python/ir/sdy_module.cc b/shardy/integrations/python/ir/sdy_module.cc
index da451fa..44c0ea2 100644
--- a/shardy/integrations/python/ir/sdy_module.cc
+++ b/shardy/integrations/python/ir/sdy_module.cc
@@ -109,7 +109,15 @@ NB_MODULE(_sdy, m) {
                              })
       .def_property_readonly("size", [](MlirAttribute self) {
         return sdyMeshAxisAttrGetSize(self);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAMeshAxisAttr(attr)) {
+              return cls(sdyMeshAxisAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "MeshAttr", sdyAttributeIsAMeshAttr)
@@ -133,7 +141,15 @@ NB_MODULE(_sdy, m) {
       .def_property_readonly("axes", [](MlirAttribute self) {
         return propertyVector<MlirAttribute>(self, sdyMeshAttrGetAxesSize,
                                              sdyMeshAttrGetAxesElem);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAMeshAttr(attr)) {
+              return cls(sdyMeshAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "SubAxisInfoAttr", sdyAttributeIsASubAxisInfoAttr)
@@ -150,7 +166,15 @@ NB_MODULE(_sdy, m) {
           [](MlirAttribute self) { return sdySubAxisInfoAttrGetPreSize(self); })
       .def_property_readonly("size", [](MlirAttribute self) {
         return sdySubAxisInfoAttrGetSize(self);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsASubAxisInfoAttr(attr)) {
+              return cls(sdySubAxisInfoAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "AxisRefAttr", sdyAttributeIsAnAxisRefAttr)
@@ -175,7 +199,15 @@ NB_MODULE(_sdy, m) {
         MlirAttribute subAxisInfo = sdyAxisRefAttrGetSubAxisInfo(self);
         return subAxisInfo.ptr == nullptr ? std::nullopt
                                           : std::optional(subAxisInfo);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAnAxisRefAttr(attr)) {
+              return cls(sdyAxisRefAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "DimensionShardingAttr", sdyAttributeIsADimensionShardingAttr)
@@ -205,7 +237,15 @@ NB_MODULE(_sdy, m) {
       .def_property_readonly("priority", [](MlirAttribute self) {
         int64_t priority = sdyDimensionShardingAttrGetPriority(self);
         return priority == -1 ? std::nullopt : std::optional(priority);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsADimensionShardingAttr(attr)) {
+              return cls(sdyDimensionShardingAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "TensorShardingAttr", sdyAttributeIsATensorShardingAttr)
@@ -251,7 +291,15 @@ NB_MODULE(_sdy, m) {
         return propertyVector<MlirAttribute>(
             self, sdyTensorShardingAttrGetUnreducedAxesSize,
             sdyTensorShardingAttrGetUnreducedAxesElem);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsATensorShardingAttr(attr)) {
+              return cls(sdyTensorShardingAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "TensorShardingPerValueAttr",
@@ -270,7 +318,15 @@ NB_MODULE(_sdy, m) {
         return propertyVector<MlirAttribute>(
             self, sdyTensorShardingPerValueAttrGetShardingsSize,
             sdyTensorShardingPerValueAttrGetShardingsElem);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsATensorShardingPerValueAttr(attr)) {
+              return cls(sdyTensorShardingPerValueAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "DimMappingAttr", sdyAttributeIsADimMappingAttr)
@@ -288,7 +344,15 @@ NB_MODULE(_sdy, m) {
         return propertyVector<intptr_t>(self,
                                         sdyDimMappingAttrGetFactorIndicesSize,
                                         sdyDimMappingAttrGetFactorIndicesElem);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsADimMappingAttr(attr)) {
+              return cls(sdyDimMappingAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "TensorMappingAttr", sdyAttributeIsATensorMappingAttr)
@@ -310,7 +374,15 @@ NB_MODULE(_sdy, m) {
                              })
       .def_property_readonly("rank", [](MlirAttribute self) {
         return sdyTensorMappingAttrGetRank(self);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsATensorMappingAttr(attr)) {
+              return cls(sdyTensorMappingAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
       m, "OpShardingRuleAttr", sdyAttributeIsAOpShardingRuleAttr)
@@ -394,6 +466,14 @@ NB_MODULE(_sdy, m) {
             return propertyVector<intptr_t>(
                 self, sdyOpShardingRuleAttrGetBlockedPropagationFactorsSize,
                 sdyOpShardingRuleAttrGetBlockedPropagationFactorsElem);
+          })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAOpShardingRuleAttr(attr)) {
+              return cls(sdyOpShardingRuleAttrMaybeDowncast(attr));
+            }
+            return nb::none();
           });

   mlir::python::nanobind_adaptors::mlir_attribute_subclass(
@@ -417,7 +497,67 @@ NB_MODULE(_sdy, m) {
            })
       .def("__len__", [](MlirAttribute& self) {
         return sdyManualAxesAttrGetAxesSize(self);
-      });
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAManualAxesAttr(attr)) {
+              return cls(sdyManualAxesAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });
+
+  mlir::python::nanobind_adaptors::mlir_attribute_subclass(
+      m, "AxisRefListAttr", sdyAttributeIsAAxisRefListAttr)
+      .def_classmethod(
+          "get",
+          [](nb::object cls, const std::vector<MlirAttribute>& axisRefs,
+             MlirContext ctx) {
+            return cls(sdyAxisRefListAttrGet(ctx, axisRefs.size(),
+                                             axisRefs.data()));
+          },
+          nb::arg("cls"), nb::arg("axis_refs"),
+          nb::arg("context").none() = nb::none(),
+          "Creates an AxisRefListAttr with the given axis references.")
+      .def_property_readonly("axis_refs", [](MlirAttribute self) {
+        return propertyVector<MlirAttribute>(
+            self, sdyAxisRefListAttrGetAxisRefsSize,
+            sdyAxisRefListAttrGetAxisRefsElem);
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAAxisRefListAttr(attr)) {
+              return cls(sdyAxisRefListAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });
+
+  mlir::python::nanobind_adaptors::mlir_attribute_subclass(
+      m, "ListOfAxisRefListsAttr", sdyAttributeIsAListOfAxisRefListsAttr)
+      .def_classmethod(
+          "get",
+          [](nb::object cls, const std::vector<MlirAttribute>& axisRefLists,
+             MlirContext ctx) {
+            return cls(sdyListOfAxisRefListsAttrGet(ctx, axisRefLists.size(),
+                                                  axisRefLists.data()));
+          },
+          nb::arg("cls"), nb::arg("axis_ref_lists"),
+          nb::arg("context").none() = nb::none(),
+          "Creates a ListOfAxisRefListsAttr with the given axis reference lists.")
+      .def_property_readonly("axis_ref_lists", [](MlirAttribute self) {
+        return propertyVector<MlirAttribute>(
+            self, sdyListOfAxisRefListsAttrGetAxisRefListsSize,
+            sdyListOfAxisRefListsAttrGetAxisRefListsElem);
+      })
+      .def_classmethod(
+          "maybe_downcast",
+          [](nb::object cls, MlirAttribute attr) -> std::variant<MlirAttribute, nb::object> {
+            if (sdyAttributeIsAListOfAxisRefListsAttr(attr)) {
+              return cls(sdyListOfAxisRefListsAttrMaybeDowncast(attr));
+            }
+            return nb::none();
+          });
 }

 }  // namespace
