
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/tutorial_01_get_started.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_tutorial_01_get_started.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_tutorial_01_get_started.py:


Getting Started
===============

**Author**: Yi-Hsiang Lai (seanlatias@github)

In this tutorial, we demonstrate the basic usage of HeteroCL.

Import HeteroCL
---------------
We usually use ``hcl`` as the acronym of HeteroCL.

.. GENERATED FROM PYTHON SOURCE LINES 16-19

.. code-block:: default


    import heterocl as hcl








.. GENERATED FROM PYTHON SOURCE LINES 20-31

Initialize the Environment
--------------------------
We need to initialize the environment for each HeteroCL application. We can
do this by calling the API ``hcl.init()``. We can also set the default data
type for every computation via this API. The default data type is **32-bit**
integers.

.. note::

   For more information on the data types, please see
   :ref:`sphx_glr_gallery_tutorial_05_dtype.py`.

.. GENERATED FROM PYTHON SOURCE LINES 31-34

.. code-block:: default


    hcl.init()








.. GENERATED FROM PYTHON SOURCE LINES 35-51

Algorithm Definition
--------------------
After we initialize, we define the algorithm by using a Python function
definition, where the arguments are the input tensors. The function can
optionally return tensors as outputs. In this example, the two inputs are a
scalar `a` and a tensor `A`, and the output is also a tensor `B`. The main
difference between a scalar and a tensor is that *a scalar cannot be updated*.

Within the algorithm definition, we use HeteroCL APIs to describe the
operations. In this example, we use a tensor-based declarative-style
operation ``hcl.compute``. We also show the equivalent  Python code.

.. note::

   For more information on the APIs, please see
   :ref:`sphx_glr_gallery_tutorial_03_api.py`

.. GENERATED FROM PYTHON SOURCE LINES 51-66

.. code-block:: default



    def simple_compute(a, A):
        B = hcl.compute(A.shape, lambda x, y: A[x, y] + a.v, "B")
        """
        The above API is equivalent to the following Python code.

        for x in range(0, 10):
            for y in range(0, 10):
                B[x, y] = A[x, y] + a
        """

        return B









.. GENERATED FROM PYTHON SOURCE LINES 67-82

Inputs/Outputs Definition
-------------------------
One of the advantages of such *modularized algorithm definition* is that we
can reuse the defined function with different input settings. We use
``hcl.placeholder`` to set the inputs, where we specify the shape, name,
and data type. The shape must be specified and should be in the form of a
**tuple**. If it is empty (i.e., `()`), the returned object is a *scalar*.
Otherwise, the returned object is a *tensor*. The rest two fields are
optional. In this example, we define a scalar input `a` and a
two-dimensional tensor input `A`.

.. note::

   For more information on the interfaces, please see
   :obj:`heterocl.placeholder`

.. GENERATED FROM PYTHON SOURCE LINES 82-86

.. code-block:: default


    a = hcl.placeholder((), "a")
    A = hcl.placeholder((10, 10), "A")








.. GENERATED FROM PYTHON SOURCE LINES 87-94

Apply Hardware Customization
----------------------------
Usually, our next step is apply various hardware customization techniques to
the application. In this tutorial, we skip this step which will be discussed
in the later tutorials. However, we still need to build a default schedule
by using ``hcl.create_schedule`` whose inputs are a list of inputs and
the Python function that defines the algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 94-97

.. code-block:: default


    s = hcl.create_schedule([a, A], simple_compute)








.. GENERATED FROM PYTHON SOURCE LINES 98-103

Inspect the Intermediate Representation (IR)
--------------------------------------------
A HeteroCL program will be lowered to an IR before backend code generation.
HeteroCL provides an API for users to inspect the lowered IR. This could be
helpful for debugging.

.. GENERATED FROM PYTHON SOURCE LINES 103-106

.. code-block:: default


    print(hcl.lower(s))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    module {
      func.func @top(%arg0: memref<1xi32>, %arg1: memref<10x10xi32>) -> memref<10x10xi32> attributes {itypes = "ss", otypes = "s"} {
        %0 = memref.alloc() {name = "B"} : memref<10x10xi32>
        affine.for %arg2 = 0 to 10 {
          affine.for %arg3 = 0 to 10 {
            %1 = affine.load %arg1[%arg2, %arg3] {from = "A"} : memref<10x10xi32>
            %2 = affine.load %arg0[0] {from = "a"} : memref<1xi32>
            %3 = arith.extsi %1 : i32 to i33
            %4 = arith.extsi %2 : i32 to i33
            %5 = arith.addi %3, %4 : i33
            %6 = arith.trunci %5 : i33 to i32
            affine.store %6, %0[%arg2, %arg3] {to = "B"} : memref<10x10xi32>
          } {loop_name = "y"}
        } {loop_name = "x", op_name = "B"}
        return %0 : memref<10x10xi32>
      }
    }





.. GENERATED FROM PYTHON SOURCE LINES 107-113

Create the Executable
---------------------
The next step is to build the executable by using ``hcl.build``. You can
define the target of the executable, where the default target is `llvm`.
Namely, the executable will be run on CPU. The input for this API is the
schedule we just created.

.. GENERATED FROM PYTHON SOURCE LINES 113-116

.. code-block:: default


    f = hcl.build(s)








.. GENERATED FROM PYTHON SOURCE LINES 117-125

Prepare the Inputs/Outputs for the Executable
---------------------------------------------
To run the generated executable, we can feed it with Numpy arrays by using
``hcl.asarray``. This API transforms a Numpy array to a HeteroCL container
that is used as inputs/outputs to the executable. In this tutorial, we
randomly generate the values for our input tensor `A`. Note that since we
return a new tensor at the end of our algorithm, we also need to prepare
an input array for tensor `B`.

.. GENERATED FROM PYTHON SOURCE LINES 125-133

.. code-block:: default


    import numpy as np

    hcl_a = 10
    np_A = np.random.randint(100, size=A.shape)
    hcl_A = hcl.asarray(np_A)
    hcl_B = hcl.asarray(np.zeros(A.shape))








.. GENERATED FROM PYTHON SOURCE LINES 134-137

Run the Executable
------------------
With the prepared inputs/outputs, we can finally feed them to our executable.

.. GENERATED FROM PYTHON SOURCE LINES 137-140

.. code-block:: default


    f(hcl_a, hcl_A, hcl_B)








.. GENERATED FROM PYTHON SOURCE LINES 141-145

View the Results
----------------
To view the results, we can transform the HeteroCL tensors back to Numpy
arrays by using ``asnumpy()``.

.. GENERATED FROM PYTHON SOURCE LINES 145-153

.. code-block:: default


    np_A = hcl_A.asnumpy()
    np_B = hcl_B.asnumpy()

    print(hcl_a)
    print(np_A)
    print(np_B)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    10
    [[62 25 50 69  9 28  4 35 85 92]
     [80 83 85 20 99 43  5 15 99 75]
     [28 52 29 19 86 94 99 81  5 92]
     [30 51 88  8 23 32 91 86 50 90]
     [43 54 36 82 37 18 78 84 87 17]
     [66  7 94 85 81 22 13 41 30 28]
     [42  4 87 65 84 74 83 30 80 21]
     [81 42 11 36 47 42  0 53  0 66]
     [58 78 94 83  0 77 72 34 79  6]
     [28 81 39 61 33  6 26 65 51 31]]
    [[ 72  35  60  79  19  38  14  45  95 102]
     [ 90  93  95  30 109  53  15  25 109  85]
     [ 38  62  39  29  96 104 109  91  15 102]
     [ 40  61  98  18  33  42 101  96  60 100]
     [ 53  64  46  92  47  28  88  94  97  27]
     [ 76  17 104  95  91  32  23  51  40  38]
     [ 52  14  97  75  94  84  93  40  90  31]
     [ 91  52  21  46  57  52  10  63  10  76]
     [ 68  88 104  93  10  87  82  44  89  16]
     [ 38  91  49  71  43  16  36  75  61  41]]




.. GENERATED FROM PYTHON SOURCE LINES 154-155

Let's run a test

.. GENERATED FROM PYTHON SOURCE LINES 155-157

.. code-block:: default


    assert np.array_equal(np_B, np_A + 10)








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.158 seconds)


.. _sphx_glr_download_gallery_tutorial_01_get_started.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tutorial_01_get_started.py <tutorial_01_get_started.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tutorial_01_get_started.ipynb <tutorial_01_get_started.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
