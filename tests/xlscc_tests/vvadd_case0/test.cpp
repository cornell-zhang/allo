
// Test harness for sequential logic with channels
#include <iostream>
#include <cstdint>

// Include the mock headers
#include "xls_builtin.h"
#include "xls_int.h"

// Wrap the ac_int alias
template <int Width, bool Signed = true>
using ac_int = XlsInt<Width, Signed>;

// Generated code (remove the #include directives that reference XLS paths)

//===------------------------------------------------------------*- C++ -*-===//
//
// Automatically Generated by Allo (XLS [CC] Backend)
//
//===----------------------------------------------------------------------===//
#include <cstdint>

template <int Width, bool Signed = true>
using ac_int = XlsInt<Width, Signed>;

/// This is top function.

// ---- TestBlock with embedded function (register mode) ----
class TestBlock {
public:
  __xls_channel<int, __xls_channel_dir_In> v0_in;
  __xls_channel<int, __xls_channel_dir_In> v1_in;
  __xls_channel<int, __xls_channel_dir_Out> out;

  #pragma hls_top
  void vvadd() {
    // L2
     int v0[16];
     int v1[16];
     #pragma hls_pipeline_init_interval 1
     for (int _idx = 0; _idx < 16; ++_idx) {
       v0[_idx] = v0_in.read();
     }
     #pragma hls_pipeline_init_interval 1
     for (int _idx = 0; _idx < 16; ++_idx) {
       v1[_idx] = v1_in.read();
     }
     int c[16] /* int c[16] */;	// L4
     #pragma hls_unroll yes
     for (int v3 = 0; v3 < 16; v3++) {	// L5
       c[v3] = 0;	// L5
     }
     #pragma hls_pipeline_init_interval 1
     for (int i = 0; i < 16; i++) {	// L6
       int v5 = v0[i];	// L7
       int v6 = v1[i];	// L8
       ac_int<33, true> v7 = v5;	// L9
       ac_int<33, true> v8 = v6;	// L10
       ac_int<33, true> v9 = v7 + v8;	// L11
       int v10 = v9;	// L12
       c[i] = v10;	// L13
     }
     #pragma hls_pipeline_init_interval 1
     for (int _idx = 0; _idx < 16; ++_idx) {
       out.write(c[_idx]);
     }

  }
};


int main() {
    TestBlock block;
    
    block.v0_in.push_input(0);
    block.v0_in.push_input(1);
    block.v0_in.push_input(2);
    block.v0_in.push_input(3);
    block.v0_in.push_input(4);
    block.v0_in.push_input(5);
    block.v0_in.push_input(6);
    block.v0_in.push_input(7);
    block.v0_in.push_input(8);
    block.v0_in.push_input(9);
    block.v0_in.push_input(10);
    block.v0_in.push_input(11);
    block.v0_in.push_input(12);
    block.v0_in.push_input(13);
    block.v0_in.push_input(14);
    block.v0_in.push_input(15);
    block.v1_in.push_input(16);
    block.v1_in.push_input(17);
    block.v1_in.push_input(18);
    block.v1_in.push_input(19);
    block.v1_in.push_input(20);
    block.v1_in.push_input(21);
    block.v1_in.push_input(22);
    block.v1_in.push_input(23);
    block.v1_in.push_input(24);
    block.v1_in.push_input(25);
    block.v1_in.push_input(26);
    block.v1_in.push_input(27);
    block.v1_in.push_input(28);
    block.v1_in.push_input(29);
    block.v1_in.push_input(30);
    block.v1_in.push_input(31);

    // Run the function multiple times to process all data
    for (int i = 0; i < 148; i++) {
        try {
            block.vvadd();
        } catch (...) {
            // Input channels may be empty
        }
    }
    
    // Read output data
    for (int i = 0; i < 16; i++) {
        try {
            int val = block.out.pop_output();
            std::cout << val << " ";
        } catch (...) {
            std::cout << "ERR ";
        }
    }
    std::cout << std::endl;
    
    return 0;
}
