# Copyright Allo authors. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
# pylint: disable=consider-using-with

import os
import sys
import importlib
import inspect
import subprocess

type_map = {
    "float32": "float",
    "float64": "double",
    "int32": "int",
    "uint32": "unsigned int",
    "uint8": "unsigned char",
    "uint1": "bool",
}


class IPModule:
    def __init__(self, top, headers, impls, signature, include_paths=[], link_hls=True):
        self.top = top
        self.headers = headers
        self.impls = impls
        self.signature = signature
        self.include_paths = include_paths
        self.link_hls = link_hls
        # Parse signature
        arg_types = signature.split("],")
        self.args = []
        for arg_type in arg_types:
            arg_type = arg_type.strip()
            ele_type = arg_type.split("[")[0].strip()
            # pylint: disable=eval-used
            shape = eval(f'({arg_type.split("[")[1].split("]")[0].strip()})')
            self.args.append((ele_type, shape))
        self.lib_name = f"py{self.top}"
        self.c_wrapper_file = f"/tmp/allo/{self.lib_name}.cpp"

    def generate_pybind11_wrapper(self):
        os.makedirs("/tmp/allo", exist_ok=True)
        # Generate pybind11 wrapper
        out_str = "// Auto-generated by Allo\n\n"
        # Add headers
        out_str += "#include <iostream>\n"
        out_str += "#include <pybind11/numpy.h>\n"
        out_str += "#include <pybind11/pybind11.h>\n"
        for header in self.headers:
            out_str += f'#include "{header}"\n'
        # Add source headers
        out_str += "\nnamespace py = pybind11;\n\n"
        # Generate function interface
        out_str += f"void py{self.top}(\n"
        for i, (arg_type, _) in enumerate(self.args):
            resolved_type = type_map.get(arg_type)
            out_str += f"  py::array_t<{resolved_type}> &arg{i}"
            out_str += ",\n" if i < len(self.args) - 1 else ") {\n"
        # Generate function body
        out_str += "\n"
        for i in range(len(self.args)):
            out_str += f"  py::buffer_info buf{i} = arg{i}.request();\n"
        # Pointer reads and writes numpy.ndarray
        out_str += "\n"
        for i, (arg_type, arg_shape) in enumerate(self.args):
            resolved_type = type_map.get(arg_type)
            out_str += f"  {resolved_type} *p_arg{i} = ({resolved_type} *)buf{i}.ptr;\n"
            out_str += f"  {resolved_type} (*p_arg{i}_2d)[{arg_shape[-1]}] = "
            out_str += (
                f"reinterpret_cast<{resolved_type} (*)[{arg_shape[-1]}]>(p_arg{i});\n"
            )
        # function call
        out_str += "\n"
        arg_names = [f"p_arg{i}_2d" for i in range(len(self.args))]
        out_str += f"  {self.top}({', '.join(arg_names)});\n"
        # Return
        out_str += "}\n\n"
        # Add pybind11 wrapper
        out_str += f"\nPYBIND11_MODULE({self.lib_name}, m) {{\n"
        out_str += f'  m.def("{self.top}", &py{self.top}, "{self.top} wrapper");\n'
        out_str += "}\n"
        with open(self.c_wrapper_file, "w", encoding="utf-8") as f:
            f.write(out_str)

    def compile(self):
        if self.link_hls:
            if os.system("which vivado_hls >> /dev/null") != 0:
                raise RuntimeError("Please install Vivado HLS and add it to your PATH")
            self.include_paths.append(
                "/".join(os.popen("which vivado_hls").read().split("/")[:-2])
                + "/include"
            )
        cmd = "g++ -shared -std=c++11 -fPIC"
        cmd += " `python3 -m pybind11 --includes`"
        abs_path = os.path.dirname(os.path.abspath(inspect.stack()[2][1]))
        self.include_paths += [abs_path]
        cmd += " -I" + " -I".join(self.include_paths)
        abs_impls = []
        for impl in self.impls:
            abs_impls.append(os.path.join(abs_path, impl))
        srcs = abs_impls + [self.c_wrapper_file]
        cmd += " " + " ".join(srcs)
        cmd += f" -o /tmp/allo/py{self.top}`python3-config --extension-suffix`"
        subprocess.Popen(cmd, shell=True).wait()

    def __call__(self, *args):
        self.generate_pybind11_wrapper()
        self.compile()
        sys.path.append("/tmp/allo")
        self.lib = importlib.import_module(f"py{self.top}")
        return getattr(self.lib, f"{self.top}")(*args)
