# Copyright Allo authors. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
# pylint: disable=consider-using-with

import os
import sys
import importlib
import inspect
import subprocess

type_map = {
    "float32": "float",
    "float64": "double",
    "int32": "int",
    "uint32": "unsigned int",
    "uint8": "unsigned char",
    "uint1": "bool",
}


class IPModule:
    def __init__(self, top):
        self.top = top
        sys.path.append("/tmp/allo")
        self.lib = importlib.import_module(f"py{top}")

    def __call__(self, *args):
        return getattr(self.lib, f"{self.top}")(*args)


# pylint: disable=dangerous-default-value
def load_hls(top, headers, impls, signature, include_paths=[], link_hls=True):
    lib_name = f"py{top}"
    os.makedirs("/tmp/allo", exist_ok=True)
    pybind_impl_name = f"/tmp/allo/{lib_name}.cpp"
    arg_types = signature.split("],")
    args = []
    for arg_type in arg_types:
        arg_type = arg_type.strip()
        ele_type = arg_type.split("[")[0].strip()
        # pylint: disable=eval-used
        shape = eval(f'({arg_type.split("[")[1].split("]")[0].strip()})')
        args.append((ele_type, shape))
    # Generate pybind11 wrapper
    out_str = "// Auto-generated by Allo\n\n"
    # Add headers
    out_str += "#include <iostream>\n"
    out_str += "#include <pybind11/numpy.h>\n"
    out_str += "#include <pybind11/pybind11.h>\n"
    for header in headers:
        out_str += f'#include "{header}"\n'
    # Add source headers
    out_str += "\nnamespace py = pybind11;\n\n"
    # Generate function interface
    out_str += f"void py{top}(\n"
    for i, (arg_type, _) in enumerate(args):
        resolved_type = type_map.get(arg_type)
        out_str += f"  py::array_t<{resolved_type}> &arg{i}"
        out_str += ",\n" if i < len(args) - 1 else ") {\n"
    # Generate function body
    out_str += "\n"
    for i in range(len(args)):
        out_str += f"  py::buffer_info buf{i} = arg{i}.request();\n"
    # Pointer reads and writes numpy.ndarray
    out_str += "\n"
    for i, (arg_type, arg_shape) in enumerate(args):
        resolved_type = type_map.get(arg_type)
        out_str += f"  {resolved_type} *p_arg{i} = ({resolved_type} *)buf{i}.ptr;\n"
        out_str += f"  {resolved_type} (*p_arg{i}_2d)[{arg_shape[-1]}] = "
        out_str += (
            f"reinterpret_cast<{resolved_type} (*)[{arg_shape[-1]}]>(p_arg{i});\n"
        )
    # function call
    out_str += "\n"
    arg_names = [f"p_arg{i}_2d" for i in range(len(args))]
    out_str += f"  {top}({', '.join(arg_names)});\n"
    # Return
    out_str += "}\n\n"
    # Add pybind11 wrapper
    out_str += f"\nPYBIND11_MODULE({lib_name}, m) {{\n"
    out_str += f'  m.def("{top}", &py{top}, "{top} wrapper");\n'
    out_str += "}\n"
    with open(pybind_impl_name, "w", encoding="utf-8") as f:
        f.write(out_str)

    # Compilation
    if link_hls:
        if os.system("which vivado_hls >> /dev/null") != 0:
            raise RuntimeError("Please install Vivado HLS and add it to your PATH")
        include_paths.append(
            "/".join(os.popen("which vivado_hls").read().split("/")[:-2]) + "/include"
        )
    cmd = "g++ -shared -std=c++11 -fPIC"
    cmd += " `python3 -m pybind11 --includes`"
    abs_path = os.path.dirname(os.path.abspath(inspect.stack()[1][1]))
    include_paths += [abs_path]
    cmd += " -I" + " -I".join(include_paths)
    abs_impls = []
    for impl in impls:
        abs_impls.append(os.path.join(abs_path, impl))
    srcs = abs_impls + [pybind_impl_name]
    cmd += " " + " ".join(srcs)
    cmd += f" -o /tmp/allo/py{top}`python3-config --extension-suffix`"
    print(cmd)
    subprocess.Popen(cmd, shell=True).wait()
    return IPModule(top)
