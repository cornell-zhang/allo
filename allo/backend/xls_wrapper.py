import re
from typing import List, Tuple

CHANNEL_HEADER = r"""//=============================================================================
// Auto generated wrapper
//=============================================================================
template<typename T>
using InputChannel = __xls_channel<T, __xls_channel_dir_In>;
template<typename T>
using OutputChannel = __xls_channel<T, __xls_channel_dir_Out>;
template<typename T, int Size>
using Memory = __xls_memory<T, Size>;

"""

class AffineForBound:
    iv: str        # induction variable, e.g. "%arg2"
    lower: int     # lower bound, e.g. 0
    upper: int     # upper bound (exclusive), e.g. 32
    raw_line: str  # full line for debugging

AFFINE_FOR_RE = re.compile(
    r'^\s*affine\.for\s+(%[\w\d]+)\s*=\s*([0-9]+)\s+to\s+([0-9]+)'
)

def parse_affine_for_bounds(mlir_text: str) -> List[AffineForBound]:
    """
    Scan MLIR text and return a list of all affine.for bounds.
    e.x. 'affine.for %arg2 = 0 to 32 ...'
    """
    bounds: List[AffineForBound] = []

    for line in mlir_text.splitlines():
        m = AFFINE_FOR_RE.match(line)
        if not m:
            continue
        iv, lo_str, hi_str = m.groups()
        bounds.append(
            AffineForBound(
                iv=iv,
                lower=int(lo_str),
                upper=int(hi_str),
                raw_line=line,
            )
        )
    return bounds

def get_loop_extents(mlir_text: str) -> List[int]:
    """
    Return a list of extents (upper - lower) for each affine.for in module
    """
    bounds = parse_affine_for_bounds(mlir_text)
    return [b.upper - b.lower for b in bounds]

from typing import List, Tuple

def render_testblock(inputs: List[str],
                     outputs: List[str],
                     memory: List[Tuple[int, str]],
                     function_names: Tuple[str, str],
                     top_param: List[str],
                     combinational: bool) -> str:

    # --- Channels ---
    input_channels = "\n    ".join(
        f"InputChannel<int> {name};" for name in inputs
    )
    output_channels = "\n    ".join(
        f"OutputChannel<int> {name};" for name in outputs
    )
    memory_blocks = "\n    ".join(
        f"Memory<int, {size}> {name};" for size, name in memory
    )

    if combinational:
        # Combinational block: return type is int
        run_body = f"""
    #pragma hls_top
    int {function_names[0]}({", ".join(f"int {param}" for param in top_param)}) {{
        return {function_names[1]}({", ".join(f"{param}" for param in top_param)});
    }}
"""
    else:
        # Sequential block: return type is void
        run_body = f"""
    #pragma hls_top
    void {function_names[0]}() {{
        // TODO: Fill in sequential FSM logic
    }}
"""

    # --- Build class ---
    testblock = f"""class TestBlock {{
public:
    {input_channels}
    {output_channels}
    {memory_blocks}
    {run_body}
}};
"""

    return testblock


def wrap_xlscc(mlir_module_text: str,
               core_code: str,
               top_name: str,
               wrapper_name: str) -> str:
    """
    mlir_module_text: MLIR (string) with affine.for loops.
    core_code:        C++ code produced by emitXlscc (contains 'top_name').
    Returns:          Full C++ code with channel, core code, etc. wrapped in Xls [cc] Style
    """
    parts: List[str] = []
    parts.append(CHANNEL_HEADER)
    parts.append("// ---- Begin core code generated by emitXlscc ----\n")
    parts.append(core_code)
    parts.append("\n// ---- End core code ----\n\n")
    parts.append(render_testblock(None)) #TODO
    return "".join(parts)
