# Copyright Allo authors. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

import numpy as np
from .utils import format_str
from ..ir.transform import find_func_in_module
from ..utils import get_func_inputs_outputs

header = """
//=============================================================================
// Auto generated by Allo
//=============================================================================

#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>
#include <cstring>
#include <cstdlib>

// Catapult HLS headers
#include <ac_int.h>
#include <ac_fixed.h>
#include <ac_channel.h>

#include "kernel.h"

using namespace std;
"""

main_header = """
int main(int argc, char** argv) {
"""

dtype_size_map = {
    "int8": 1,
    "int16": 2,
    "int32": 4,
    "int64": 8,
    "uint8": 1,
    "uint16": 2,
    "uint32": 4,
    "uint64": 8,
    "float16": 2,
    "float32": 4,
    "float64": 8,
}

ctype_map = {
    "bf16": "std::bfloat16_t",
    "f32": "float",
    "f64": "double",
    "i8": "int8_t",
    "i16": "int16_t",
    "i32": "int32_t",
    "i64": "int64_t",
    "ui1": "bool",
    "ui8": "uint8_t",
    "ui16": "uint16_t",
    "ui32": "uint32_t",
    "ui64": "uint64_t",
}


def codegen_host(top, module):
    """Generate C++ host code for Catapult HLS functional simulation.

    Parameters
    ----------
    top : str
        Top-level function name
    module : Module
        MLIR module containing the function
    """
    func = find_func_in_module(module, top)
    inputs, outputs = get_func_inputs_outputs(func)

    out_str = format_str(header, indent=0, strip=False)
    out_str += format_str(main_header, indent=0, strip=False)

    # Process inputs
    for i, (in_dtype, in_shape) in enumerate(inputs):
        # Read from file (text mode)
        out_str += format_str(f'ifstream ifile{i}("input{i}.data");', 4)
        out_str += format_str(f"if (!ifile{i}.is_open()) {{", 4)
        out_str += format_str('cerr << "Error: Could not open input file.\\n";', 8)
        out_str += format_str("return 1;", 8)
        out_str += format_str("}", 4)

        size = np.prod(in_shape) if len(in_shape) > 0 else 1

        # Buffer allocation
        if len(in_shape) == 0:  # Scalar
            scalar_type = ctype_map.get(str(in_dtype), "int")
            out_str += format_str(f"{scalar_type} source_in{i};", 4)
            out_str += format_str(f"ifile{i} >> source_in{i};", 4)
        else:  # Array
            c_type = ctype_map.get(str(in_dtype), "int")
            out_str += format_str(f"vector<{c_type}> source_in{i}({size});", 4)
            out_str += format_str(f"for (int k = 0; k < {size}; k++) {{", 4)
            out_str += format_str(f"ifile{i} >> source_in{i}[k];", 8)
            out_str += format_str("}", 4)

    # Process outputs
    for i, (out_dtype, out_shape) in enumerate(outputs):
        size = np.prod(out_shape) if len(out_shape) > 0 else 1
        out_str += format_str(
            f"vector<{ctype_map.get(str(out_dtype), 'int')}> source_out{i}({size}, 0);",
            4,
        )

    out_str += "\n"

    # Call the top function
    # Note: signatures in Catapult HLS generated code generally match what we emitted.
    # Arrays are pointers or ac_channel references.
    # Scalars are values.
    # We need to construct the call arguments.

    args = []

    # Inputs
    for i, (in_dtype, in_shape) in enumerate(inputs):
        if len(in_shape) == 0:
            args.append(f"source_in{i}")
        else:
            args.append(f"source_in{i}.data()")

    # Outputs
    for i in range(len(outputs)):
        args.append(f"source_out{i}.data()")

    # Handling explicit return vs output arguments handled in `inputs` (legacy)
    # If num_output_args > 0, some inputs are actually outputs (pointers)
    # The logic in Vitis handles this.

    # Call kernel
    out_str += format_str(f"{top}({', '.join(args)});", 4)
    out_str += "\n"

    # Write outputs to files
    if len(outputs) > 0:
        for i, (_, out_shape) in enumerate(outputs):
            out_str += format_str(f'ofstream ofile{i}("output{i}.data");', 4)
            out_str += format_str(f"if (!ofile{i}) {{", 4)
            out_str += format_str(
                f'cerr << "Failed to open output file {i}!" << endl;', 8
            )
            out_str += format_str("return 1;", 8)
            out_str += format_str("}", 4)
            size = np.prod(out_shape) if len(out_shape) > 0 else 1
            out_str += format_str(f"for (int k = 0; k < {size}; k++) {{", 4)
            out_str += format_str(f"ofile{i} << source_out{i}[k] << endl;", 8)
            out_str += format_str("}", 4)
            out_str += format_str(f"ofile{i}.close();", 4)

    out_str += format_str("return 0;", 4)
    out_str += "}\n"

    return out_str


def codegen_tcl(top, configs):
    """Generate TCL script for Catapult HLS synthesis"""
    frequency = configs["frequency"]
    clock_period = 1000 / frequency
    mode = configs.get("mode", "csyn")

    out_str = """# Project root directory
set sfd [file dir [info script]]

# Create new solution
solution new -state initial
solution options defaults
solution options set /Input/CppStandard c++11
solution options set /Input/CompilerFlags {{-D_GLIBCXX_USE_CXX11_ABI=0}}

# Add source files
solution file add "$sfd/kernel.cpp" -type C++
"""

    # Only include host.cpp for csim mode
    if mode == "csim":
        out_str += 'solution file add "$sfd/host.cpp" -type C++ -exclude true\n'

    out_str += f"""
# Set top-level design function
directive set -DESIGN_HIERARCHY {top}

# Set clock constraints
directive set -CLOCKS {{clk {{-CLOCK_PERIOD {clock_period:.1f}}}}}

# Set output language
solution options set /Output/OutputVerilog true
solution options set /Output/OutputVHDL false

# Flow
go analyze
go compile
"""

    if mode == "csim":
        out_str += """
solution app linkage
solution app execution
"""

    # Continue synthesis if not just csim
    if mode == "csyn":
        out_str += """
solution library add nangate-45nm_beh
solution library add ccs_sample_mem
go assembly
go extract
"""

    out_str += "\nexit\n"
    return out_str
